generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String  @id @default(uuid()) @db.Uuid
  address   String  @unique @db.VarChar
  username  String? @unique @db.VarChar
  bio       String? @db.VarChar
  avatarUrl String? @map("avatar_url") @db.VarChar
  network   Network @default(Solana)
  premium   Boolean @default(false)

  tokens            Token[]
  tokenOwners       TokenOwner[]
  comments          Comment[]
  commentLikes      CommentLike[]
  tokenTransactions TokenTransaction[]
  follower          UserConnection[]   @relation("follower")
  following         UserConnection[]   @relation("following")
  config            Config?

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("user")
}

model UserConnection {
  id          String @id @default(uuid()) @db.Uuid
  followerId  String @map("follower_id") @db.Uuid
  followingId String @map("following_id") @db.Uuid

  follower  User @relation(fields: [followerId], references: [id], onDelete: Cascade, name: "follower")
  following User @relation(fields: [followingId], references: [id], onDelete: Cascade, name: "following")

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@unique([followerId, followingId])
  @@map("user_connection")
}

model Comment {
  id            String  @id @default(uuid()) @db.Uuid
  content       String  @db.Text
  attachmentUrl String? @map("attachment_url") @db.VarChar
  authorId      String  @map("author_id") @db.Uuid
  tokenId       String  @map("token_id") @db.Uuid
  parentId      String? @map("parent_id") @db.Uuid

  replies Comment[]     @relation("CommentReplies")
  likes   CommentLike[]

  parent Comment? @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  token  Token    @relation(fields: [tokenId], references: [id], onDelete: Cascade)
  author User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@index([authorId])
  @@index([tokenId])
  @@map("comment")
}

model CommentLike {
  id        String @id @default(uuid()) @db.Uuid
  userId    String @map("user_id") @db.Uuid
  commentId String @map("comment_id") @db.Uuid

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)

  @@unique([userId, commentId])
  @@map("comment_like")
}

model Token {
  id                      String    @id @default(uuid()) @db.Uuid
  address                 String    @unique @db.VarChar
  name                    String    @db.VarChar
  price                   Float?
  uri                     String    @db.VarChar // image url
  ticker                  String    @db.VarChar
  metadata                Json
  description             String    @db.Text
  isHighlight             Boolean   @default(false) @map("is_highlight")
  network                 Network   @default(Solana)
  bondingCurveTarget      Float     @default(0) @map("bonding_curve_target") // amount to complete curve target (fetch from Contract)
  isCompletedBondingCurve Boolean   @default(false) @map("is_completed_bonding_curve")
  createdAtBondingCurve   DateTime? @map("created_at_bonding_curve")
  isCompletedKingOfHill   Boolean   @default(false) @map("is_completed_king_of_hill") // True => having marketCapacity is gte the highest marketCapacity of token (not ever bonding curve => isCompletedBondingCurve = false) AND greater than 70% its bondingCurveTarget
  createdAtKingOfHill     DateTime? @map("created_at_king_of_hill")
  bump                    Boolean?  @default(false) // on chain
  creatorAddress          String    @map("creator_address") @db.VarChar
  marketCapacity          Float     @default(28) @map("market_capacity") @db.DoublePrecision
  volumn                  Float     @default(0)
  // totalSupply             Decimal? // 1.000.000

  bumpAt    DateTime? @map("pump_at") @db.Timestamptz(3) // Time on chain
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  creator          User               @relation(fields: [creatorAddress], references: [address], onDelete: Cascade)
  tokenOwners      TokenOwner[]
  comments         Comment[]
  TokenTransaction TokenTransaction[]
  tokenKey         TokenKey           @relation(fields: address, references: publicKey)

  @@index([creatorAddress, createdAt(sort: Desc)])
  @@map("token")
}

model TokenKey {
  id         String   @id @default(uuid()) @db.Uuid
  privateKey String   @unique @map("private_key")
  publicKey  String   @unique @map("public_key")
  isPicked   Boolean  @default(false) @map("is_picked")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(3)

  Token Token?

  @@index([publicKey])
  @@index([isPicked])
  @@map("token_key")
}

model TokenOwner {
  id           String  @id @default(uuid()) @db.Uuid
  userAddress  String  @map("user_address") @db.VarChar
  tokenAddress String  @map("token_address") @db.VarChar
  amount       Decimal @db.Decimal(20, 0)

  token Token @relation(fields: [tokenAddress], references: [address], onDelete: Cascade)
  user  User  @relation(fields: [userAddress], references: [address], onDelete: Cascade)

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@unique([userAddress, tokenAddress])
  @@map("token_owner")
}

model Config {
  id          String  @id @default(uuid()) @db.Uuid
  maxSlippage Float   @default(1) @map("max_slippage")
  priorityFee Decimal @default(0.01) @map("priority_fee")
  userId      String  @unique @map("user_id") @db.Uuid

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("config")
}

model TokenTransaction {
  id           String          @id @default(uuid()) @db.Uuid
  signature    String          @unique @db.VarChar
  amount       Decimal         @db.Decimal(20, 0)
  tokenAddress String          @map("token_address") @db.VarChar
  lamports     Decimal         @db.Decimal(20, 0) // amout of solana coin
  date         DateTime        @db.Timestamptz(3)
  signer       String          @db.VarChar
  price        Decimal         @db.Decimal(20, 20)
  newPrice     Decimal         @map("new_price") @db.Decimal(20, 20)
  type         TransactionType
  network      Network         @default(Solana)
  createdAt    DateTime        @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt    DateTime?       @updatedAt @map("updated_at") @db.Timestamptz(3)
  createdBy    User            @relation(fields: [signer], references: [address], onDelete: Cascade)
  token        Token           @relation(fields: [tokenAddress], references: [address], onDelete: Cascade)

  @@map("token_transaction")
}

model Setting {
  key   String @id @db.VarChar(120)
  value String @db.VarChar

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("setting")
}

enum Network {
  Solana
}

enum TransactionType {
  Buy
  Sell
  Create
}
